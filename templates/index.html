<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StandardGPT</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: #f8f9fa;
            color: #333;
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
        }
        
        /* SIDEBAR DESIGN */
        .sidebar {
            width: 260px;
            background: #1a2332;
            color: white;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .logo-icon {
            width: 120px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-icon svg {
            width: 100%;
            height: 100%;
        }
        
        .logo-text {
            font-size: 18px;
            font-weight: 600;
        }
        
        .new-chat-btn {
            width: 100%;
            padding: 12px;
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }
        
        .new-chat-btn:hover {
            background: #16a34a;
            transform: translateY(-1px);
        }
        
        .new-chat-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .conversations-section {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .conversations-title {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .conversations-title svg {
            width: 16px;
            height: 16px;
        }
        
        .conversation-item {
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .conversation-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .conversation-item.active {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.3);
        }
        
        .conversation-date {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 4px;
        }
        
        .conversation-content {
            flex: 1;
            min-width: 0;
        }
        
        .conversation-title {
            font-size: 14px;
            color: white;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .conversation-menu {
            position: relative;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .conversation-item:hover .conversation-menu {
            opacity: 1;
        }
        
        .menu-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .menu-button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }
        
        .menu-button svg {
            width: 16px;
            height: 16px;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: #2d3748;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            min-width: 140px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .dropdown-item {
            padding: 8px 12px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: background 0.2s ease;
        }
        
        .dropdown-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .dropdown-item.delete {
            color: #ef4444;
        }
        
        .dropdown-item.delete:hover {
            background: rgba(239, 68, 68, 0.1);
        }
        
        .dropdown-item svg {
            width: 14px;
            height: 14px;
        }
        
        /* MAIN CONTENT DESIGN */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }
        
        .chat-header {
            padding: 20px 30px;
            border-bottom: 1px solid #e5e7eb;
            background: white;
        }
        
        .chat-title {
            font-size: 24px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            scroll-behavior: smooth;
        }
        
        .welcome-message {
            text-align: center;
            max-width: 600px;
            margin: 0 auto;
            padding: 60px 0;
        }
        
        .welcome-title {
            font-size: 32px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 16px;
        }
        
        .welcome-subtitle {
            font-size: 18px;
            color: #6b7280;
            margin-bottom: 40px;
        }
        
        .message {
            margin-bottom: 30px;
            max-width: 800px;
        }
        
        .message.user {
            margin-left: auto;
        }
        
        .message.assistant {
            margin-right: auto;
        }
        
        .message-content {
            padding: 16px 20px;
            border-radius: 12px;
            font-size: 16px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        .message.user .message-content {
            background: #22c55e;
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .message.assistant .message-content {
            background: #f3f4f6;
            color: #1f2937;
            border-bottom-left-radius: 4px;
        }
        
        /* STRUCTURED ANSWER STYLING */
        .message.assistant .message-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .message.assistant .message-content li {
            margin: 5px 0;
        }
        
        .message.assistant .message-content strong {
            font-weight: 600;
            color: #1f2937;
        }
        
        /* INPUT AREA */
        .input-area {
            padding: 20px 30px;
            border-top: 1px solid #e5e7eb;
            background: white;
        }
        
        .input-container {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }
        
        .input-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 12px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            transition: all 0.2s ease;
        }
        
        .input-wrapper:focus-within {
            border-color: #22c55e;
            background: white;
        }
        
        .question-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            font-size: 16px;
            color: #1f2937;
            resize: none;
            min-height: 24px;
            max-height: 120px;
            font-family: inherit;
        }
        
        .question-input::placeholder {
            color: #9ca3af;
        }
        
        .send-btn {
            width: 40px;
            height: 40px;
            background: #22c55e;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .send-btn:hover:not(:disabled) {
            background: #16a34a;
            transform: translateY(-1px);
        }
        
        .send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            transform: none;
        }
        
        /* PROGRESS INDICATOR */
        .progress-container {
            padding: 16px 24px;
            border-top: 1px solid #e5e7eb;
            background: #ffffff;
            display: none;
        }
        
        .progress-text {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 12px;
            font-weight: 500;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 14px;
            color: #6b7280;
            transition: all 0.3s ease;
        }
        
        .progress-item.completed {
            color: #16a34a;
        }
        
        .progress-item.active {
            color: #1f2937;
            font-weight: 500;
        }
        
        .progress-emoji {
            font-size: 18px;
            min-width: 24px;
            text-align: center;
        }
        
        .progress-emoji svg {
            width: 18px;
            height: 18px;
        }
        
        .progress-text {
            flex: 1;
        }
        
        .progress-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Clean progress bar + skeleton placeholder */
        .progress { position: relative; height: 6px; background: #f1f5f9; border-radius: 9999px; overflow: hidden; }
        .progress__bar { position: absolute; inset: 0 auto 0 0; width: 0%; background: linear-gradient(90deg, #22c55e, #16a34a); border-radius: 9999px; transition: width 200ms ease; }
        .skeleton { border-radius: 10px; height: 12px; background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 37%, #f3f4f6 63%); background-size: 400% 100%; animation: shimmer 1.2s ease-in-out infinite; }
        @keyframes shimmer { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }
        
        .progress-checkmark {
            width: 16px;
            height: 16px;
            background: #22c55e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }
        
        .progress-checkmark svg {
            width: 12px;
            height: 12px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: fixed;
                top: 0;
                left: -100%;
                z-index: 1000;
                transition: left 0.3s ease;
            }
            
            .sidebar.open {
                left: 0;
            }
            
            .main-content {
                width: 100%;
            }
        }
        
        .hidden {
            display: none !important;
        }
        
        /* SVG ICONS STYLING */
        .icon {
            width: 16px;
            height: 16px;
            display: inline-block;
            vertical-align: middle;
        }
        
        .icon-large {
            width: 20px;
            height: 20px;
        }
        
        .icon-progress {
            width: 18px;
            height: 18px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- SIDEBAR -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="logo">
                    <div class="logo-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1920 1078.907">
                            <defs>
                                <style>
                                    .cls-1 { fill: #00c785; }
                                    .cls-2 { fill: #fff; }
                                </style>
                            </defs>
                            <g>
                                <path class="cls-1" d="M431.30368,215.7787c-119.1709,0-215.77881,96.608-215.77881,215.77893,0,119.17169,96.60791,215.77893,215.77881,215.77893Z"/>
                                <polygon class="cls-1" points="215.525 863.115 431.304 647.337 215.525 647.337 215.525 863.115"/>
                                <path class="cls-2" d="M431.30368,431.55763V863.11549c119.17139,0,215.77881-96.60724,215.77881-215.77893C647.08249,528.1656,550.47507,431.55763,431.30368,431.55763Z"/>
                                <polygon class="cls-2" points="647.082 215.779 431.304 215.779 647.082 431.557 647.082 215.779"/>
                                <path class="cls-2" d="M811.49606,488.31513c-21.09521,0-36.67187-11.123-40.15185-34.17486h-21.977c2.55712,32.35107,24.30029,52.14892,61.15869,52.14892,38.72021,0,59.16455-21.56,59.16455-51.11853,0-24.47747-10.59522-41.25042-54.38867-54.5401-28.50733-8.60852-37.75586-15.18622-37.75586-31.858,0-16.30829,10.36425-26.48773,31.17822-26.48773,22.00293,0,32.39258,11.51489,35.11377,29.666H865.7236c-1.89014-25.08752-18.16553-47.6242-56.4082-47.6242-33.04346,0-54.335,18.25378-54.335,46.4768,0,25.47473,14.227,37.83045,51.42382,49.15253,31.16895,9.68158,40.44581,18.01672,40.44581,37.685C846.85007,477.42292,832.80661,488.31513,811.49606,488.31513Z"/>
                                <path class="cls-2" d="M951.24313,503.68464V487.66718a60.02488,60.02488,0,0,1-10.12109.84711c-11.13867,0-13.86328-4.60058-13.86328-15.50867V391.3614h26.31689V373.82832H927.25876V335.9015H906.05563v37.92682H885.125V391.3614h20.93066V477.031c0,21.65168,9.15381,28.89319,28.11865,28.89319C938.73239,505.92414,946.19821,505.50056,951.24313,503.68464Z"/>
                                <path class="cls-2" d="M1073.12448,475.35413V411.94788c0-29.71966-18.71191-40.69409-45.98389-40.69409-34.72168,0-47.32715,17.80811-49.28027,39.64789H998.7026c2.19385-14.39917,8.77149-23.11517,27.75879-23.11517,22.12891,0,25.64063,12.77923,25.64063,25.157v12.66229h-19.98584c-46.72363,0-59.40186,21.79078-59.40186,41.43219,0,18.09259,9.76709,39.58307,41.63135,39.58307,21.27539,0,34.45947-9.36554,39.45361-22.48144a117.01911,117.01911,0,0,0,1.89307,20.16613h19.39844A222.25736,222.25736,0,0,1,1073.12448,475.35413Zm-20.40283-31.62884c0,28.02551-8.43653,45.30261-34.06787,45.30261-16.42969,0-24.14209-10.52716-24.14209-23.24951,0-11.88947,5.94531-24.71765,37.54394-24.71765h20.666Z"/>
                                <path class="cls-2" d="M1190.48923,423.43433v80.87146h21.46191V420.12812c0-35.24164-17.36865-48.87433-41.5332-48.87433-21.3545,0-33.05567,11.33319-38.45752,23.02979.16406-5.435-.43946-17.97406-.79053-20.45526h-20.93066c.25586,5.58514.51513,13.6532.51513,40.85211v89.62536h21.29737V434.56367c0-27.37122,9.29-44.63886,32.582-44.63886C1184.07614,389.92481,1190.48923,404.46308,1190.48923,423.43433Z"/>
                                <path class="cls-2" d="M1328.43747,485.061c0,7.59076.43945,15.8089.78711,19.24475h20.93408c-.42334-8.05224-.51514-21.44781-.51514-34.00262V316.90809h-21.29785v69.98865c-3.49267-7.2146-13.38916-15.643-34.44043-15.643-35.36035,0-54.90332,30.40564-54.90332,68.07007,0,38.85925,16.75537,67.38886,50.5542,67.38886C1310.98971,506.71272,1321.59762,500.18879,1328.43747,485.061Zm-67.3667-46.69177c0-31.12311,13.87256-48.70209,35.56543-48.70209,22.06592,0,32.51562,10.58246,32.51562,46.81507,0,30.60949-5.78125,51.90875-33.87451,51.90875C1274.7568,488.391,1261.07077,470.09455,1261.07077,438.36927Z"/>
                                <path class="cls-2" d="M1479.16159,411.94788c0-29.71966-18.71192-40.69409-45.98389-40.69409-34.72168,0-47.32715,17.80811-49.28027,39.64789h20.84228c2.19385-14.39917,8.77149-23.11517,27.7583-23.11517,22.1294,0,25.64063,12.77923,25.64063,25.157v12.66229H1438.1528c-46.72314,0-59.40137,21.79078-59.40137,41.43219,0,18.09259,9.76709,39.58307,41.63135,39.58307,21.27539,0,34.45947-9.36554,39.45361-22.48144a116.96955,116.96955,0,0,0,1.89307,20.16613h19.398a222.34892,222.34892,0,0,1-1.96582-28.95166Zm-20.40332,31.77741c0,28.02551-8.436,45.30261-34.06738,45.30261-16.42969,0-24.14209-10.52716-24.14209-23.24951,0-11.88947,5.94531-24.71765,37.54394-24.71765h20.66553Z"/>
                                <path class="cls-2" d="M1539.54,400.294c0-11.98114-.0918-20.30676-.53125-26.46563H1518.0776c.34766,6.45282.51514,23.48968.51514,44.288v86.18951h21.29785V440.122c0-28.14246,12.51709-45.41,41.85889-46.46576V371.43714C1560.041,371.769,1545.6528,384.1089,1539.54,400.294Z"/>
                                <path class="cls-2" d="M1703.96286,470.30317V316.90809H1682.6655v69.98865c-3.4961-7.2146-13.39258-15.643-34.44385-15.643-35.35694,0-54.90332,30.40564-54.90332,68.07007,0,38.85925,16.7583,67.38886,50.55713,67.38886,21.43066,0,32.0415-6.52393,38.88134-21.65168,0,7.59076.43946,15.8089.78711,19.24475h20.93116C1704.05173,496.25355,1703.96286,482.858,1703.96286,470.30317ZM1649.59372,488.391c-20.52051,0-34.20655-18.29645-34.20655-50.02173,0-31.12311,13.87256-48.70209,35.56885-48.70209,22.06543,0,32.51221,10.58246,32.51221,46.81507C1683.46823,467.09174,1677.6904,488.391,1649.59372,488.391Z"/>
                                <path class="cls-2" d="M872.68356,647.26222c0,28.81884.25928,57.4718,1.89356,81.12268h-.34766c-3.24023-7.82776-12.80762-24.83149-83.68945-150.94068H761.32126V755.10658H782.0405V684.549c0-31.89124.24023-61.68048-1.04639-84.63916h.25635c3.812,7.42956,9.41943,18.61255,85.23193,155.19678h27.085V577.44422H872.68356Z"/>
                                <path class="cls-2" d="M982.292,622.05457c-39.44434,0-58.22559,32.01923-58.22559,66.28577,0,35.85645,16.04395,69.00726,56.59131,69.00726,41.73535,0,58.28565-31.83117,58.28565-69.61413C1038.94333,650.14015,1019.23532,622.05457,982.292,622.05457Zm-.34766,117.50074c-23.64648,0-35.90088-21.372-35.90088-51.41407,0-28.40008,12.08692-48.29437,35.20215-48.29437,23.82959,0,35.64453,19.66358,35.64453,47.97827C1016.8901,718.68116,1006.37106,739.55531,981.9443,739.55531Z"/>
                                <path class="cls-2" d="M1088.47018,651.09474c0-11.98114-.09131-20.30676-.53076-26.46564h-20.93115c.34765,6.45282.51514,23.48968.51514,44.288v86.18952h21.29785V690.92274c0-28.14246,12.5166-45.41,41.85888-46.46576V622.23792C1108.97165,622.56977,1094.58346,634.90968,1088.47018,651.09474Z"/>
                                <path class="cls-2" d="M1232.14255,640.60389c-3.41993-10.08935-14.13184-18.54932-34.731-18.54932-30.01514,0-53.51318,24.97687-53.51318,67.26563,0,40.43017,19.86279,66.05505,50.53222,66.05505,20.16651,0,31.62744-6.86853,38.31592-21.45416v10.71045c0,28.476-6.36621,46.79456-34.355,46.79456-16.6294,0-28.33691-7.066-31.22607-21.5727h-21.11768c1.87793,18.57465,13.415,39.01569,51.52148,39.01569,39.62745,0,55.94385-22.99817,55.94385-63.66858V662.45789c0-17.786.25928-31.6383.51514-37.82879H1233.186C1232.83786,627.60975,1232.14255,635.03925,1232.14255,640.60389Zm-32.55664,96.192c-20.69678,0-33.52686-17.4762-33.52686-47.749,0-30.325,13.00049-48.4129,34.63037-48.4129,25.36231,0,32.58789,15.21,32.58789,47.82336C1233.27731,721.26038,1224.519,736.79585,1199.58591,736.79585Z"/>
                                <path class="cls-2" d="M1337.97067,622.05457c-40.168,0-55.89648,35.376-55.89648,67.40632,0,36.00024,13.873,68.127,54.68554,68.127,34.95264,0,47.67188-23.07727,51.96094-39.346h-21.02588c-2.46533,6.82422-8.92285,21.55524-29.90771,21.55524-23.02637,0-34.15576-19.71564-33.9917-45.83362h86.78369c.0918-.82019.18359-9.17273.18359-9.90131C1390.76266,653.96156,1378.86227,622.05457,1337.97067,622.05457ZM1304.311,678.32685c1.17871-15.55285,7.30762-38.93512,33.14405-38.93512,22.63476,0,31.52636,16.7461,32.209,38.93512Z"/>
                            </g>
                        </svg>
                    </div>
                </div>
                <button class="new-chat-btn" onclick="newConversation()">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                    </svg>
                    Ny samtale
                </button>
            </div>
            
            <div class="conversations-section">
                <div class="conversations-title">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2z"/>
                    </svg>
                    Tidligere samtaler
                </div>
                <div id="conversations-list">
                    <!-- Dynamisk innhold -->
                </div>
            </div>
        </div>
        
        <!-- MAIN CONTENT -->
        <div class="main-content">
            <div class="chat-container">
                <div class="messages-area" id="messages-area">
                    <div class="welcome-message" id="welcome-message">
                        <div class="welcome-title">Hei, hva kan jeg hjelpe deg med?</div>
                        <div class="welcome-subtitle">
                            <p>StandardGPT hjelper deg med √• finne informasjon om norske standarder.</p>
                            <p> Sp√∏r om en eller flere konkrete standarder eller la meg hjelpe deg med √• finne en standard.</p>
                        </div>
                    </div>
                </div>
                
                <!-- PROGRESS INDICATOR -->
                <div class="progress-container" id="progress-container">
                    <div class="progress-text" id="progress-text">Behandler sp√∏rsm√•l...</div>
                    <div class="skeleton" id="progress-placeholder" style="width: 55%; max-width: 520px; margin-bottom: 10px;"></div>
                    <div class="progress">
                        <div class="progress__bar" id="progress-bar"></div>
                    </div>
                </div>
                
                <!-- INPUT AREA -->
                <div class="input-area">
                    <div class="input-container">
                <div class="input-wrapper">
                    <textarea 
                                id="question-input" 
                        class="question-input"
                                placeholder="Sp√∏r om standarder..." 
                                rows="1"
                                onkeydown="handleKeyDown(event)"
                                oninput="autoResize(this)"
                    ></textarea>
                            <button id="send-btn" class="send-btn" onclick="sendMessage()" disabled>
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentConversationId = null;
        let isProcessing = false;
        let eventSource = null;
        let currentSessionId = null;
        
        // NYE VARIABLER for conversation memory tracking
        let lastUserMessage = '';
        let lastSystemResponse = '';
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            // Generate or retrieve session ID
            currentSessionId = localStorage.getItem('standardgpt_session_id');
            if (!currentSessionId) {
                currentSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
                localStorage.setItem('standardgpt_session_id', currentSessionId);
            }
            console.log('üÜî Using session ID:', currentSessionId);
            
            loadConversations();
            setupInputValidation();
            
            // Focus input
            const input = document.getElementById('question-input');
            if (input) input.focus();
        });
        
        // Setup input validation
        function setupInputValidation() {
            const input = document.getElementById('question-input');
            const sendBtn = document.getElementById('send-btn');
            
            input.addEventListener('input', function() {
                const hasText = this.value.trim().length > 0;
                sendBtn.disabled = !hasText || isProcessing;
            });
        }        
        // NYTT: Rydd meldinger men bevar welcome-message elementet
        function clearMessagesButKeepWelcome() {
            const messagesArea = document.getElementById('messages-area');
            if (!messagesArea) return;
            
            // Finn alle child elements bortsett fra welcome-message
            const messagesToRemove = [];
            for (let child of messagesArea.children) {
                if (child.id !== 'welcome-message') {
                    messagesToRemove.push(child);
                }
            }
            
            // Fjern alle meldinger bortsett fra welcome-message
            messagesToRemove.forEach(element => {
                element.remove();
            });
            
            console.log('üßπ Cleared messages but kept welcome message');
        }
        
        // Auto resize textarea
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        }
        
        // Handle key down
        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        // Send message
        async function sendMessage() {
            if (isProcessing) return;
            
            const input = document.getElementById('question-input');
            const question = input.value.trim();
            
            if (!question) return;
            
            isProcessing = true;
            input.value = '';
            
            // Lagre bruker-meldingen for senere memory saving
            lastUserMessage = question;
            console.log('üíæ Stored user message for memory saving:', lastUserMessage.substring(0, 50) + '...');

            // Hide welcome message
            const welcomeMessage = document.getElementById('welcome-message');
            if (welcomeMessage) {
                welcomeMessage.classList.add('hidden');
            }
            
            // Add user message to chat
            addMessageToChat('user', question);
            
            // Show progress
            showProgress();
            
            try {
                console.log('üöÄ Sending question:', question);
                console.log('üÜî Using session ID:', currentSessionId);
                
                // VIKTIG: Generer ALLTID ny session ID for hvert sp√∏rsm√•l for √• unng√• blanding av svar
                currentSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 8)}_${Math.floor(Math.random() * 10000)}`;
                localStorage.setItem('standardgpt_session_id', currentSessionId);
                console.log('üÜî Generated fresh session ID for new question:', currentSessionId);
                
                // Start streaming request
                const response = await fetch('/api/query/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': currentSessionId
                    },
                    body: JSON.stringify({
                        question: question,
                        conversation_id: currentConversationId
                    })
                });
                
                console.log('üì° Response status:', response.status);
                console.log('üì° Response headers:', response.headers);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API Error Response:', errorText);
                    throw new Error(`API returned ${response.status}: ${errorText.substring(0, 200)}...`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Stream response data:', data);
                
                // VIKTIG: Oppdater session ID fra server response for √• sikre kontinuitet
                if (data.session_id && data.session_id !== currentSessionId) {
                    console.log('üÜî Server updated session ID from', currentSessionId, 'to', data.session_id);
                    currentSessionId = data.session_id;
                    localStorage.setItem('standardgpt_session_id', currentSessionId);
                }
                
                // Start listening to SSE stream
                startEventStream(data.stream_session_id || data.session_id);  // Use stream_session_id if available
                
            } catch (error) {
                console.error('‚ùå Error sending message:', error);
                hideProgress();
                
                // Show detailed error to user
                let errorMessage = 'Beklager, det oppstod en feil. ';
                if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Kan ikke koble til serveren. Sjekk internetttilkoblingen.';
                } else if (error.message.includes('500')) {
                    errorMessage += 'Serverfeil. Pr√∏v igjen om litt.';
                } else if (error.message.includes('400')) {
                    errorMessage += 'Ugyldig sp√∏rsm√•l. Pr√∏v √• omformulere.';
                } else {
                    errorMessage += `Teknisk feil: ${error.message}`;
                }
                
                addMessageToChat('assistant', errorMessage);
                resetInput();
            }
        }
        
        // Start event stream
        function startEventStream(sessionId) {
            console.log('üîå Starting event stream for session:', sessionId);
            
            if (eventSource) {
                console.log('üîå Closing existing event source');
                eventSource.close();
            }
            
            eventSource = new EventSource(`/api/stream/${sessionId}`);
            let currentAnswer = '';
            let answerMessageElement = null;
            let hasReceivedData = false;
            let progressUpdated = false;
            let retryCount = 0;
            const maxRetries = 3;
            
            // FORBEDRET: Mye lengre timeout for komplekse sp√∏rsm√•l
            const connectionTimeout = setTimeout(() => {
                if (!hasReceivedData && !progressUpdated) {
                    console.error('‚è∞ SSE connection timeout - ingen data mottatt');
                    eventSource.close();
                    hideProgress();
                    addMessageToChat('assistant', 'Tilkoblingen tok for lang tid √• etablere. Pr√∏ver automatisk fallback...');
                    fallbackToSyncAPI(lastUserMessage);
                }
            }, 90000); // √òkt til 90 sekunder for Railway ustabilitet
            
            // FORBEDRET: Timeout for hele prosessen
            const processingTimeout = setTimeout(() => {
                if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
                    console.error('‚è∞ SSE processing timeout - fullf√∏res ikke');
                    eventSource.close();
                    hideProgress();
                    addMessageToChat('assistant', 'Prosesseringen tok for lang tid. Pr√∏ver en enklere tiln√¶rming...');
                    fallbackToSyncAPI(lastUserMessage);
                }
            }, 180000); // 3 minutter total timeout for embedding-generering
            
            eventSource.onopen = function(event) {
                console.log('‚úÖ SSE connection opened successfully');
                hasReceivedData = true; // Mark as connected
                retryCount = 0; // Reset retry count on successful connection
            };
            
            eventSource.onmessage = async function(event) {
                hasReceivedData = true;
                clearTimeout(connectionTimeout);
                
                try {
                    const data = JSON.parse(event.data);
                    console.log('üì® SSE message received:', data.type, data);
                    
                    if (data.type === 'connected') {
                        console.log('üîó SSE connected for session:', data.session_id);
                    } else if (data.type === 'progress') {
                        progressUpdated = true;
                        updateProgress(data.stage, data.progress, data.message, data.emoji);
                    } else if (data.type === 'token') {
                        // Hide progress when streaming starts
                        if (!answerMessageElement) {
                            hideProgress();
                            answerMessageElement = addMessageToChat('assistant', '');
                        }
                        currentAnswer += data.token;
                        updateMessageContent(answerMessageElement, currentAnswer);
                        
                        if (data.is_final) {
                            console.log('‚úÖ Final token received');
                            lastSystemResponse = currentAnswer; // Lagre system response
                            clearTimeout(processingTimeout);
                            hideProgress();
                            
                            // NYTT: Eksplisitt lagring av conversation memory
                            if (lastUserMessage && lastSystemResponse) {
                                console.log('üíæ Final token: Saving conversation memory...');
                                await saveConversationMemory(lastUserMessage, lastSystemResponse);
                            }
                            
                            setTimeout(() => {
                                resetInput();
                                loadConversations();
                            }, 500);
                        }
                    } else if (data.type === 'final_answer') {
                        console.log('‚úÖ Final answer received:', data.answer.substring(0, 100) + '...');
                        lastSystemResponse = data.answer; // Lagre system response
                        
                        if (!answerMessageElement) {
                            answerMessageElement = addMessageToChat('assistant', data.answer);
                        } else {
                            updateMessageContent(answerMessageElement, data.answer);
                        }
                        clearTimeout(processingTimeout);
                        hideProgress();
                        
                        // NYTT: Eksplisitt lagring av conversation memory
                        if (lastUserMessage && lastSystemResponse) {
                            console.log('üíæ Final answer: Saving conversation memory...');
                            await saveConversationMemory(lastUserMessage, lastSystemResponse);
                        }
                        
                        setTimeout(() => {
                            resetInput();
                            loadConversations();
                        }, 500);
                    } else if (data.type === 'error') {
                        console.error('‚ùå SSE error received:', data.error);
                        clearTimeout(processingTimeout);
                        hideProgress();
                        addMessageToChat('assistant', `Feil: ${data.error}`);
                        resetInput();
                    } else if (data.type === 'conversation_id') {
                        console.log('üí¨ Conversation ID received:', data.conversation_id);
                        currentConversationId = data.conversation_id;
                        console.log('‚úÖ Updated currentConversationId:', currentConversationId);
                    } else if (data.type === 'conversation_title_update') {
                        console.log('üìù Conversation title update received:', data);
                        // Oppdater tittelen i sidebaren
                        updateConversationTitleInSidebar(data.conversation_id, data.title);
                        console.log('‚úÖ Updated conversation title in sidebar:', data.title);
                    } else if (data.type === 'keepalive') {
                        console.log('üíì SSE keepalive received');
                        // Reset timeouts on keepalive
                        if (!progressUpdated && !currentAnswer) {
                            // Extend initial timeout if no progress yet
                            clearTimeout(connectionTimeout);
                        }
                    } else {
                        console.log('‚ùì Unknown SSE message type:', data.type);
                    }
                } catch (error) {
                    console.error('‚ùå Error parsing SSE data:', error, 'Raw data:', event.data);
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('‚ùå SSE error:', error);
                console.error('‚ùå SSE readyState:', eventSource.readyState);
                console.error('‚ùå SSE url:', eventSource.url);
                
                clearTimeout(connectionTimeout);
                clearTimeout(processingTimeout);
                
                // Don't immediately close on error - let it try to reconnect
                if (eventSource.readyState === EventSource.CLOSED) {
                    console.log('üîå SSE connection closed');
                    
                    // Bare vis feilmelding hvis vi faktisk var i gang med √• prosessere
                    if (progressUpdated || currentAnswer) {
                        hideProgress();
                        addMessageToChat('assistant', 'Tilkoblingen ble avbrutt. Pr√∏v √• sp√∏rre p√• nytt.');
                        resetInput();
                    } else {
                        // Stille forbindelse uten √• vise feil - brukeren var bare inaktiv
                        console.log('üîå SSE closed during idle period - no error shown');
                    }
                }
                
                // FORBEDRET: Intelligent retry logic
                if (eventSource.readyState === EventSource.CONNECTING) {
                    console.log('üîÑ SSE is reconnecting automatically...');
                    return; // Let browser handle reconnection
                }
                
                eventSource.close();
                hideProgress();
                
                // FORBEDRET: Better error handling based on what we received
                if (!hasReceivedData && retryCount < maxRetries) {
                    retryCount++;
                    console.log(`üîÑ SSE connection failed, retry ${retryCount}/${maxRetries}...`);
                    setTimeout(() => {
                        startEventStream(sessionId);
                    }, 2000 * retryCount); // Exponential backoff
                } else if (!progressUpdated && !currentAnswer) {
                    console.log('üîÑ SSE failed early, trying fallback to sync API...');
                    fallbackToSyncAPI(lastUserMessage);
                } else if (currentAnswer && currentAnswer.length > 50 && progressUpdated) {
                    // We have partial answer AND we were actively processing, show what we got
                    console.log('‚ö†Ô∏è SSE disconnected but we have partial answer from active processing');
                    addMessageToChat('assistant', 'Tilkoblingen ble avbrutt, men her er det jeg rakk √• finne:\n\n' + currentAnswer);
                    resetInput();
                } else {
                    console.log('‚ùå SSE failed after multiple retries');
                    addMessageToChat('assistant', 'Tilkoblingen ble avbrutt og automatisk gjenoppretting feilet. Pr√∏v √• stille sp√∏rsm√•let p√• nytt.');
                    resetInput();
                }
            };
        }
        
        // NYTT: Fallback funksjon som bruker sync API
        async function fallbackToSyncAPI(question) {
            if (!question) {
                addMessageToChat('assistant', 'Kan ikke etablere tilkobling til serveren. Pr√∏v igjen.');
                return;
            }
            
            try {
                console.log('üîÑ Fallback: Using sync API for question:', question.substring(0, 50) + '...');
                console.log('üîÑ Fallback: Using session ID:', currentSessionId);
                
                // VIKTIG: S√∏rg for at vi har session ID ogs√• i fallback
                if (!currentSessionId) {
                    currentSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
                    localStorage.setItem('standardgpt_session_id', currentSessionId);
                    console.log('üÜî Fallback: Generated new session ID:', currentSessionId);
                }
                
                showProgress();
                updateProgress('fallback', 50, 'Bruker alternativ tilkobling...');
                
                const response = await fetch('/api/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': currentSessionId
                    },
                    body: JSON.stringify({
                        question: question,
                        conversation_id: currentConversationId
                    }),
                    timeout: 30000  // 30 sekunder timeout
                });
                
                if (!response.ok) {
                    throw new Error(`Sync API returned ${response.status}`);
                }
                
                const data = await response.json();
                hideProgress();
                
                if (data.answer) {
                    console.log('‚úÖ Fallback: Received answer from sync API');
                    lastSystemResponse = data.answer;
                    addMessageToChat('assistant', data.answer);
                    
                    // Lagre conversation memory
                    if (lastUserMessage && lastSystemResponse) {
                        console.log('üíæ Fallback: Saving conversation memory...');
                        await saveConversationMemory(lastUserMessage, lastSystemResponse);
                    }
                    
                    setTimeout(() => {
                        resetInput();
                        loadConversations();
                    }, 500);
                } else {
                    throw new Error('No answer received from sync API');
                }
                
            } catch (error) {
                console.error('‚ùå Fallback sync API also failed:', error);
                hideProgress();
                addMessageToChat('assistant', 'Beklager, b√•de streaming og alternativ tilkobling feilet. Pr√∏v igjen senere.');
                resetInput();
            }
        }
        
        // Add message to chat
        function addMessageToChat(role, content) {
            const messagesArea = document.getElementById('messages-area');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = formatMessage(content);
            
            messageDiv.appendChild(contentDiv);
            messagesArea.appendChild(messageDiv);
            
            // Smart scroll - only scroll to bottom if user is already near bottom
            smartScrollToBottom();
            
            return contentDiv;
        }
        
        // Track if user is manually scrolling
        let userIsScrolling = false;
        let scrollTimeout;
        
        // Smart scroll - auto-scroll unless user has scrolled up recently
        function smartScrollToBottom() {
            const messagesArea = document.getElementById('messages-area');
            if (!messagesArea) return;
            
            // If user has scrolled up recently, don't auto-scroll
            if (userIsScrolling) {
                return;
            }
            
            // Always auto-scroll to bottom (this is the default behavior we want)
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }
        
        // Track user scroll behavior - only when scrolling up
        let lastScrollTop = 0;
        document.getElementById('messages-area').addEventListener('scroll', function() {
            const messagesArea = this;
            const currentScrollTop = messagesArea.scrollTop;
            
            // Only set userIsScrolling if user scrolled up (not down/auto-scroll)
            if (currentScrollTop < lastScrollTop) {
                userIsScrolling = true;
                
                // Clear existing timeout
                clearTimeout(scrollTimeout);
                
                // Reset after user stops scrolling for 2 seconds
                scrollTimeout = setTimeout(() => {
                    userIsScrolling = false;
                }, 2000);
            }
            
            lastScrollTop = currentScrollTop;
        });

        // Format message content
        function formatMessage(content) {
            // Convert bullet points to HTML
            content = content.replace(/^[\-\*\‚Ä¢]\s+(.+)$/gm, '<li>$1</li>');
            content = content.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            
            // Format bold text
            content = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Format line breaks
            content = content.replace(/\n/g, '<br>');
            
            return content;
        }
        
        // Update message content
        function updateMessageContent(element, content) {
            element.innerHTML = formatMessage(content);
            
            // Smart scroll - only scroll to bottom if user is already near bottom
            smartScrollToBottom();
        }
        
        // Show progress
        function showProgress(message = 'Behandler sp√∏rsm√•l...', progress = 0) {
            const box = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            const text = document.getElementById('progress-text');
            if (!box || !bar || !text) return;
            
            box.style.display = 'block';
            text.textContent = message;
            const safe = Math.max(progress, 8);
            bar.style.width = safe + '%';
        }
        
        // Hide progress
        function hideProgress() {
            const box = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            if (!box || !bar) return;
            bar.style.width = '100%';
            setTimeout(() => {
                box.style.display = 'none';
                bar.style.width = '0%';
            }, 200);
        }
        
        // Reset input
        function resetInput() {
            isProcessing = false;
            const input = document.getElementById('question-input');
            const sendBtn = document.getElementById('send-btn');
            
            sendBtn.disabled = input.value.trim().length === 0;
        }
        
        // Load conversations
        async function loadConversations() {
            try {
                const response = await fetch('/api/conversations');
                if (!response.ok) {
                    throw new Error(`Failed to load conversations: ${response.status}`);
                }
                
                const data = await response.json();
                
                const conversationsList = document.getElementById('conversations-list');
                if (!conversationsList) {
                    console.error('Conversations list element not found');
                    return;
                }
                
                conversationsList.innerHTML = '';
                
                if (data.conversations && data.conversations.length > 0) {
                    // Group by date
                    const groupedConversations = groupConversationsByDate(data.conversations);
                    
                    for (const [dateGroup, conversations] of Object.entries(groupedConversations)) {
                        const dateHeader = document.createElement('div');
                        dateHeader.className = 'conversation-date';
                        dateHeader.textContent = dateGroup;
                        conversationsList.appendChild(dateHeader);
                        
                        conversations.forEach(conv => {
                            const convElement = document.createElement('div');
                            convElement.className = 'conversation-item';
                            convElement.dataset.conversationId = conv.id; // Add data attribute
                            
                            // Use arrow function to preserve context and avoid null reference
                            convElement.addEventListener('click', (event) => {
                                // Don't load conversation if clicking on menu button or dropdown
                                if (event.target.closest('.conversation-menu')) {
                                    return;
                                }
                                loadConversation(conv.id);
                            });
                            
                            convElement.innerHTML = `
                                <div class="conversation-content">
                                    <div class="conversation-title">${conv.title}</div>
                                </div>
                                <div class="conversation-menu">
                                    <button class="menu-button" onclick="toggleConversationMenu(event, '${conv.id}')">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                            <circle cx="12" cy="5" r="2"/>
                                            <circle cx="12" cy="12" r="2"/>
                                            <circle cx="12" cy="19" r="2"/>
                                        </svg>
                                    </button>
                                    <div class="dropdown-menu" id="menu-${conv.id}">
                                        <div class="dropdown-item delete" onclick="deleteConversation(event, '${conv.id}')">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M3 6h18v2H3V6zm2 3v11c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V9H5zm3 2h2v7H8v-7zm4 0h2v7h-2v-7z"/>
                                                <path d="M10 2h4v2H10V2z"/>
                                            </svg>
                                            Slett samtale
                                        </div>
                                    </div>
                                </div>
                            `;
                            
                            conversationsList.appendChild(convElement);
                        });
                    }
                } else {
                    conversationsList.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">Ingen samtaler enn√•</div>';
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
                const conversationsList = document.getElementById('conversations-list');
                if (conversationsList) {
                    conversationsList.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">Kunne ikke laste samtaler</div>';
                }
            }
        }
        
        // Group conversations by date
        function groupConversationsByDate(conversations) {
            const groups = {};
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            conversations.forEach(conv => {
                const convDate = new Date(conv.last_message_at);
                let dateKey;
                
                if (convDate.toDateString() === today.toDateString()) {
                    dateKey = 'I dag';
                } else if (convDate.toDateString() === yesterday.toDateString()) {
                    dateKey = 'Denne uken';
                } else {
                    dateKey = 'Tidligere';
                }
                
                if (!groups[dateKey]) {
                    groups[dateKey] = [];
                }
                groups[dateKey].push(conv);
            });
            
            return groups;
        }
        
        // Load conversation
        async function loadConversation(conversationId) {
            try {
                const response = await fetch(`/api/conversations/${conversationId}`);
                if (!response.ok) {
                    throw new Error(`Failed to load conversation: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Clear current chat
                const messagesArea = document.getElementById('messages-area');
                if (messagesArea) {
                    clearMessagesButKeepWelcome();
                }
                
                const welcomeMessage = document.getElementById('welcome-message');
                if (welcomeMessage) {
                    welcomeMessage.classList.add('hidden');
                }
                
                // Load messages
                if (data.messages && Array.isArray(data.messages)) {
                    data.messages.forEach(msg => {
                        addMessageToChat('user', msg.question);
                        addMessageToChat('assistant', msg.answer);
                    });
                }
                
                // Update current conversation
                currentConversationId = conversationId;
                
                // VIKTIG: Generer unik per-conversation session ID for memory isolasjon
                const conversationSessionId = `conversation_${conversationId}_${Date.now()}`;
                
                // Alltid sett ny session ID for denne spesifikke samtalen
                currentSessionId = conversationSessionId;
                localStorage.setItem('standardgpt_session_id', currentSessionId);
                console.log('üÜî Loaded conversation: Set unique session ID:', currentSessionId);
                
                // VIKTIG: Gjenoppbygg conversation memory for denne spesifikke samtalen
                if (data.messages && data.messages.length > 0) {
                    try {
                        console.log('üîÑ Rebuilding conversation memory for:', conversationId);
                        
                        const rebuildResponse = await fetch('/api/session/rebuild', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Session-ID': currentSessionId
                            },
                            body: JSON.stringify({
                                conversation_id: conversationId,
                                messages: data.messages
                            })
                        });
                        
                        if (rebuildResponse.ok) {
                            const rebuildData = await rebuildResponse.json();
                            console.log('‚úÖ Conversation memory rebuilt successfully:', rebuildData);
                        } else {
                            console.warn('‚ö†Ô∏è Could not rebuild conversation memory:', rebuildResponse.status);
                        }
                        
                    } catch (err) {
                        console.warn('‚ö†Ô∏è Error rebuilding conversation memory:', err);
                    }
                }
                
                // Update active conversation in sidebar
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Find and activate the clicked conversation item
                const conversationItems = document.querySelectorAll('.conversation-item');
                conversationItems.forEach(item => {
                    if (item.dataset.conversationId === conversationId) {
                        item.classList.add('active');
                    }
                });
                
                console.log('‚úÖ Conversation loaded:', conversationId);
                
            } catch (error) {
                console.error('‚ùå Error loading conversation:', error);
                alert('Kunne ikke laste samtale');
            }
        }
        
        // Start new chat
        function startNewChat() {
            // Clear current chat
            const messagesArea = document.getElementById('messages-area');
            if (messagesArea) {
                clearMessagesButKeepWelcome();
            }
            
            const welcomeMessage = document.getElementById('welcome-message');
            if (welcomeMessage) {
                welcomeMessage.classList.remove('hidden');
            }
            
            // Reset current conversation
            currentConversationId = null;
            currentSessionId = null;
            
            // Clear active conversation in sidebar
            const conversationItems = document.querySelectorAll('.conversation-item');
            if (conversationItems) {
                conversationItems.forEach(item => {
                    if (item && item.classList) {
                        item.classList.remove('active');
                    }
                });
            }
            
            // Reset input
            resetInput();
        }

        // Toggle conversation menu
        function toggleConversationMenu(event, conversationId) {
            event.stopPropagation(); // Prevent conversation click
            
            // Close all other menus
            document.querySelectorAll('.dropdown-menu').forEach(menu => {
                if (menu.id !== `menu-${conversationId}`) {
                    menu.classList.remove('show');
                }
            });
            
            // Toggle current menu
            const menu = document.getElementById(`menu-${conversationId}`);
            if (menu) {
                menu.classList.toggle('show');
            }
        }
        
        // Delete conversation
        async function deleteConversation(event, conversationId) {
            event.stopPropagation(); // Prevent conversation click
            
            if (!confirm('Er du sikker p√• at du vil slette denne samtalen?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/conversations/${conversationId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to delete conversation: ${response.status}`);
                }
                
                // Remove from UI
                const conversationElement = document.querySelector(`[data-conversation-id="${conversationId}"]`);
                if (conversationElement) {
                    conversationElement.remove();
                }
                
                // If this was the active conversation, clear the chat
                if (currentConversationId === conversationId) {
                    currentConversationId = null;
                    clearMessagesButKeepWelcome();
                    const welcomeMessage = document.getElementById('welcome-message');
                    if (welcomeMessage) {
                        welcomeMessage.classList.remove('hidden');
                    }
                }
                
                console.log('‚úÖ Conversation deleted successfully');
                
            } catch (error) {
                console.error('‚ùå Error deleting conversation:', error);
                alert('Kunne ikke slette samtalen. Pr√∏v igjen.');
            }
        }
        
        // Close dropdown menus when clicking outside
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.conversation-menu')) {
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });

        // New conversation button handler - FORBEDRET SESSION MANAGEMENT
        async function newConversation() {
            console.log('üîÑ Starting NEW conversation...');
            
            try {
                // Clear existing chat
                const messagesArea = document.getElementById('messages-area');
                if (messagesArea) {
                    clearMessagesButKeepWelcome();
                }
                
                // Show welcome message
                const welcomeMessage = document.getElementById('welcome-message');
                if (welcomeMessage) {
                    welcomeMessage.classList.remove('hidden');
                }
                
                // Reset conversation state
                currentConversationId = null;
                
                // VIKTIG: Generer HELT NY session_id for √• skille fra forrige memory
                currentSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
                localStorage.setItem('standardgpt_session_id', currentSessionId);
                console.log('üÜî NEW conversation: Generated fresh session ID:', currentSessionId);
                
                // VIKTIG: Explicit clear av conversation memory p√• backend
                clearConversationMemoryExplicit();
                
                // Remove active state from all conversations
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Create a new conversation placeholder in database immediately
                const response = await fetch('/api/conversations/placeholder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': currentSessionId
                    },
                    body: JSON.stringify({
                        session_id: currentSessionId
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentConversationId = data.conversation_id;
                    console.log('‚úÖ Created conversation placeholder:', currentConversationId);
                    
                    // Reload conversations to show "Ny samtale" in sidebar
                    await loadConversations();
                    
                    // Mark the new conversation as active
                    const conversationItems = document.querySelectorAll('.conversation-item');
                    conversationItems.forEach(item => {
                        if (item.dataset.conversationId === currentConversationId) {
                            item.classList.add('active');
                        }
                    });
                } else {
                    console.error('‚ùå Failed to create conversation placeholder');
                }
                
                console.log('‚úÖ New conversation started with clean memory');
                
            } catch (error) {
                console.error('‚ùå Error creating new conversation:', error);
            }
        }
        
        // Update conversation title in sidebar
        function updateConversationTitleInSidebar(conversationId, newTitle) {
            const conversationItems = document.querySelectorAll('.conversation-item');
            conversationItems.forEach(item => {
                if (item.dataset.conversationId === conversationId) {
                    const titleElement = item.querySelector('.conversation-content .conversation-title');
                    if (titleElement) {
                        titleElement.textContent = newTitle;
                        console.log(`‚úÖ Updated title for conversation ${conversationId}: "${newTitle}"`);
                    }
                }
            });
        }

        // NYTT: Explicit clear av conversation memory p√• backend
        async function clearConversationMemoryExplicit() {
            if (!currentSessionId) return;
            
            try {
                console.log('üßπ Clearing conversation memory explicitly for session:', currentSessionId);
                
                const response = await fetch('/api/session/clear', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': currentSessionId
                    }
                });
                
                if (response.ok) {
                    console.log('‚úÖ Conversation memory cleared successfully');
                } else {
                    console.warn('‚ö†Ô∏è Could not clear conversation memory:', response.status);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error clearing conversation memory:', error);
            }
        }
        
        // NYTT: Funksjon for eksplisitt lagring av conversation memory
        async function saveConversationMemory(userMessage, systemResponse) {
            if (!userMessage || !systemResponse || !currentSessionId) {
                console.warn('‚ö†Ô∏è Cannot save memory: missing data', {userMessage: !!userMessage, systemResponse: !!systemResponse, sessionId: !!currentSessionId});
                return false;
            }
            
            try {
                console.log('üíæ Saving conversation memory explicitly...');
                console.log(`üíæ User: ${userMessage.substring(0, 50)}...`);
                console.log(`üíæ System: ${systemResponse.substring(0, 50)}...`);
                
                const response = await fetch('/api/session/save-memory', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': currentSessionId
                    },
                    body: JSON.stringify({
                        user_message: userMessage,
                        system_response: systemResponse
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Conversation memory saved successfully:', data);
                    return true;
                } else {
                    console.error('‚ùå Failed to save conversation memory:', response.status, await response.text());
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error saving conversation memory:', error);
                return false;
            }
        }

        function updateProgress(stage, progress, message, emoji = '') {
            console.log(`üéØ updateProgress: stage="${stage}", progress=${progress}, message="${message}", emoji="${emoji}"`);
            
            // Frontend progress mapping for smooth progression
            let frontendMessage = message;
            let frontendProgress = progress;
            
            // Fix problematic messages and progression
            if (message.includes('S√∏kestrategi valgt!')) {
                // Change to "Velger s√∏kestrategi..." and set to 80%
                frontendMessage = 'Velger s√∏kestrategi...';
                frontendProgress = 80;
            } else if (message.includes('Genererer svar...')) {
                // Set to 100% for final step
                frontendProgress = 100;
            } else if (message.includes('Starter behandling')) {
                frontendProgress = 5;
            } else if (message.includes('Validerer inndata')) {
                frontendProgress = 10;
            } else if (message.includes('Analyserer sp√∏rsm√•l')) {
                frontendProgress = 15;
            } else if (message.includes('Trekker ut standarder')) {
                frontendProgress = 25;
            } else if (message.includes('Velger s√∏kestrategi')) {
                frontendProgress = 35;
            } else if (message.includes('Genererer embeddings')) {
                frontendProgress = 45;
            } else if (message.includes('Bygger s√∏kesp√∏rring')) {
                frontendProgress = 55;
            } else if (message.includes('S√∏ker i standarddatabase')) {
                frontendProgress = 65;
            } else if (message.includes('Formaterer s√∏keresultater')) {
                frontendProgress = 75;
            }
            
            // Use cleaned message without emoji for cleaner UI
            showProgress(frontendMessage, frontendProgress);
            
            // NYTT: Ogs√• oppdater progress indikator
            progressUpdated = true;
            console.log(`‚úÖ Progress updated: ${frontendMessage} (${frontendProgress}%)`);
        }
    </script>
</body>
</html> 